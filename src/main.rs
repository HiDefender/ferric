extern crate fnv;
#[macro_use]
extern crate clap;

mod file;
mod daikon;

use clap::App;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::process::Command;

fn main() {
    let matches = clap_app!(myapp =>
        (name: "ferric")
        (version: "0.1")
        (author: "Jared Soundy. <jared_soundy@gmail.com>")
        (about: "A Rust front-end for Daikon")
        (@subcommand daikon =>
            (about: "invokes daikon on trace files generated by \"cargo test\"")
            (@arg debug: -d "Run in debug mode.")
        )
        (@subcommand clean =>
            (about: "removes the ferric folder")
        )
    ).get_matches();


    match matches.subcommand_name() {
        Some("daikon") | Some("daikon-d") => {
            file::check_or_create_ferric_folder().expect("Unexpected error while creating the ferric folder.");
            let files = file::read_cur_src().unwrap();
            let mut instumentor  = daikon::Instrumentor::new();
            let mut instr_files: HashMap<PathBuf, String> = HashMap::new();
            for (pathbuf, file) in &files {
                println!("{:?}", pathbuf);
                let file = instumentor.instrument_file(file);
                instr_files.insert(pathbuf.clone(), file);
            }
            let mut ferric_folder = file::get_ferric_decls_path().expect("Could not get ferric folder address.");
            let decls_file = instumentor.get_decls();
            instr_files.insert(ferric_folder, decls_file);
            file::create_and_write_files(&instr_files).expect("Unexpected error while writing instrumented code.");
            file::copy_toml_file().expect("Could not copy Cargo.toml.");
            let mut ferric_folder = file::get_ferric_decls_path().expect("Could not get ferric folder address.");
            ferric_folder.pop();
            let output = Command::new("cargo")
                .current_dir(ferric_folder)
                .args(&["test", "--", "--test-threads=1", "--nocapture"])
                .output()
                .expect("\"cargo new ferric\" failed.");
            let raw_dtrace = String::from_utf8_lossy(&output.stderr).into_owned();
            file::clean_and_write_dtrace_file(raw_dtrace, false).expect("Could not clean trace file.");
        },
        Some("clean") => file::ferric_clean().expect("ferric clean failed"),
        None        => println!("Please use a subcommand. Try \"ferric help\""),
        _           => unreachable!(),
    }
}